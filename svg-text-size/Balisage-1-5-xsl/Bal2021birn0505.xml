<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="balisage-author.css"?>
<?xml-model href="../Balisage-1-5-rng/balisage-1-5.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0-subset Balisage-1.5">
    <title>How long is my SVG <code>&lt;text&gt;</code> element?</title>
    <info>
        <abstract>
            <para>SVG layout requires that the developer be in control of the dimensions of the
                objects that must be placed in the coordinate space. It is easy to specify (or
                compute based on other specifications) the size (bounding box height and width) of
                many SVG objects (rectangles, circles, lines), but identifying the bounding box for
                text is challenging because SVG text does not know its own length.</para>
            <para>In this report we explore two methods for working around this limitation. The
                first method, implemented in XSLT, determines the length of SVG
                    <code>&lt;text&gt;</code> elements and uses that information for layout purposes
                as the SVG is created. The second method, implemented in JavaScript, determines the
                length of SVG <code>&lt;text&gt;</code> objects as the SVG is rendered in a browser
                and uses the information to control the layout at rendering time.</para>
        </abstract>
        <author>
            <personname>
                <firstname>David</firstname>
                <othername>J.</othername>
                <surname>Birnbaum</surname>
            </personname>
            <personblurb>
                <para>David J. Birnbaum is Professor of Slavic Languages and Literatures at the
                    University of Pittsburgh. He has been involved in the study of electronic text
                    technology since the mid-1980s, has delivered presentations at a variety of
                    digital humanities and electronic text technology conferences, and has served on
                    the board of the Association for Computers and the Humanities, the editorial
                    board of <emphasis role="ital">Markup languages: theory and practice</emphasis>,
                    and the Text Encoding Initiative Technical Council. Much of his electronic text
                    work intersects with his research in medieval Slavic manuscript studies, but he
                    also often writes about issues in the philosophy of markup. For the past ten
                    years he has been teaching an XML-oriented course in the University Honors
                    College at the University of Pittsburgh entitled <quote>Computational methods in
                        the humanities</quote> (<link>http://dh.obdurodon.org</link>).</para>
            </personblurb>
            <affiliation>
                <orgname>University of Pittsburgh</orgname>
            </affiliation>
            <email>djbpitt@gmail.com</email>
            <link>http://www.obdurodon.org</link>
        </author>
        <author>
            <personname>
                <firstname>Charlie</firstname>
                <surname>Taylor</surname>
            </personname>
            <personblurb>
                <para>Charlie Taylor is an undergraduate at the University of Pittsburgh studying
                    History of Art &amp; Architecture and Classics. She was enrolled in Dr.
                    Birnbaum’s <quote>Computational methods in the humanities</quote> class in
                    Spring 2020, and currently serves as a teaching assistant for the course. She
                    will graduate in Spring 2023 and plans to pursue a graduate degree in Medieval
                    Studies.</para>
            </personblurb>
            <affiliation>
                <orgname>University of Pittsburgh</orgname>
            </affiliation>
            <email>clt76@pitt.edu</email>
        </author>
        <keywordset role="author">
            <keyword>SVG</keyword>
            <keyword>font metrics</keyword>
        </keywordset>
    </info>
    <section xml:id="intro">
        <title>The problem</title>
        <para>SVG layout requires that the developer be in control of the dimensions of the objects
            that must be placed in the coordinate space. It is easy to specify (or compute based on
            other specifications) the size (bounding box height and width) of many SVG objects
            (rectangles, circles, lines), but identifying the bounding box for text is challenging
            because SVG text does not know its own length (or, perhaps surprisingly, its height).
            Developers are able to specify a <code>@font-size</code>, which is related to (but does
            not match) the height of the font (from baseline to baseline) as rendered<footnote>
                <para>If the user does not specify a font size, the default is 16 pixels, which
                    corresponds to specifying the value <code>"medium"</code> for a
                        <code>@font-size</code> attribute on the SVG <code>&lt;text&gt;</code>
                    element. The <code>@font-size</code> setting may be modified before rendering
                    with the global SVG <code>@transform</code> attribute. See below concerning the
                    actual height of SVG <code>&lt;text&gt;</code> elements, which is not the same
                    as the value of the declared or implicit <code>@font-size</code>.</para>
            </footnote>, but the length of a string of characters depends on the widths of the
            individual characters, and those widths are not exposed in any convenient, accessible
            way in a regular XML development environment.</para>
        <para>Our test case for exploring and addressing the challenges <code>&lt;text&gt;</code>
            elements pose for layout is an SVG bar graph like the following:<footnote>
                <para>The sample graphs for this report are based on materials from Charlie Taylor’s
                        <quote>Van Gogh as a ‘tortured genius”</quote>
                        (<link>http://vangogh.obdurodon.org</link>,
                        <link>https://github.com/charlietaylor98/vangogh-gang</link>), which she
                    undertook in Spring 2020 together with Colin Woelfel, Nate McDowell, and Rachel
                    Saula as part of David J. Birnbaum’s <quote>Computational methods in the
                        humanities</quote> course (<link>http://dh.obdurodon.org</link>) in the
                    University Honors College at the University of Pittsburgh.</para>
            </footnote></para>
        <figure xml:id="figure-01" xreflabel="Sample bar graph">
            <mediaobject>
                <imageobject>
                    <imagedata width="12in" fileref="includes/diagonal-graph.svg"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>In this graph the bars rest on the X axis, and they bear individual slanted labels
            below. Under those labels we label the X axis itself. The challenge involves determining
            the Y position of the general label for the X axis, since that position will depend on
            the length of the longest bar label, and will therefore vary according to the specific
            values of those bar labels. If you are like us, you place that label with a combination
            of guesswork and trial and error and then hard-code a magic number, which—predictably
            and understandably—breaks as soon as you try to reuse the code with new input.<footnote>
                <para>Placing the X axis label more precisely in a way that takes into account the
                    lengths and positions of all of the bar labels is a version of the same type of
                    task, although a more complicated one. For example, if the leftmost and
                    rightmost bar labels are the longest, a human designer might choose to label the
                    X axis, if it is short enough, slightly between them, instead of fully below
                    them. Similarly, a human designer might choose, if the bar labels happen to be
                    longer on one side of the graph than the other, to place the general axis label
                    on the shorter side, below the bar labels on that side, but not below the
                    longest label (on the other side).</para>
                <para>Our modest goal is simply to place the general label for the X axis with
                    reliable precision below the longest bar label. Whether the more exact placement
                    described above would be worth the extra effort cannot be determined in any
                    general way, but because it builds on the same methods as the simpler task, it
                    could, at least in principle, be implemented as an extension of the solution to
                    that simpler task by taking more measurements into consideration when placing
                    the label.</para>
            </footnote></para>
    </section>
    <section xml:id="solutions">
        <title>Solutions</title>
        <para> This presentation explores two strategies for working around the difficulty of
            knowing the length of an SVG <code>&lt;text></code> element:</para>
        <orderedlist>
            <listitem>
                <para><emphasis role="bold">The XSLT approach:</emphasis> As a preprocessing step
                    before undertaking the transformation that outputs the SVG bar graph, create a
                    mapping between characters and their individual widths by querying the font metrics.<footnote>
                        <para><emphasis role="ital">Character</emphasis> refers to an informational
                            unit of writing independently of its presentation. <emphasis role="ital"
                                >Glyph</emphasis> refers to a font resource used to render a
                            character. A text strings in our SVG is made up of characters; the
                            rendering of the text inside a browser is a made up of glyphs.</para>
                        <para>The distinction between character and glyph is important in many
                            contexts because it is not necessarily one to one. For example, the
                            writing unit <code>"ä"</code> may be represented as either a single
                            composite character (Unicode U+00E4 <quote>Latin Small Letter A with
                                Diaeresis</quote>) or a sequence of two Unicode characters, one for
                            the base character <code>"a"</code> (U+0061 <quote>Latin Small Letter
                                A</quote>) and one for the combining diacritic (U+0308
                                <quote>Combining diaeresis</quote>). Whether a writing unit is
                            represented as two characters informationally or as one is independent
                            of whether it is rendered in a browser or other platform as two glyphs
                            or as one.</para>
                        <para>In this report we use both terms because we focus on situations where
                            the mapping between characters and glyphs is one to one, or where the
                            distinction does not affect the computation of text length.</para>
                    </footnote> Font metrics are not accessible by default to an XSLT processor, but
                    we can extract and format them in a preprocessing step and then import a
                    machine-accessing mapping from glyph to width into the XSLT that generates the
                    SVG. With this approach, the length of a <code>&lt;text&gt;</code> element is
                    presumed to be the sum of the widths of its constituent characters. If the text
                    strings are horizontal or vertical, the length is one of the dimensions of the
                    bounding box, and the other dimension is (approximately) the font size. If the
                    text is rotated, we can apply trigonometric functions to the length of the text
                    (which functions as the hypotenuse) and the angle of rotation to compute the
                    dimensions (the adjacent and opposites sides of a right triangle) of the
                    bounding box.</para>
            </listitem>
            <listitem>
                <para><emphasis role="bold">The JavaScript approach:</emphasis> Output SVG
                    components that must be stacked vertically as separate <code>&lt;svg&gt;</code>
                    elements with no height specified. These would wind up with a default height in
                    a browser that would be wrong initially. We use CSS Flexbox to stack the
                        <code>&lt;svg&gt;</code> elements vertically, and employ the JavaScript
                        <code>element.getBBox()</code> function to compute the dimensions of the
                    bounding box for each of the vertically stacked <code>&lt;svg&gt;</code>
                    elements. We can then write the computed height values of each
                        <code>&lt;svg&gt;</code> element into the DOM, effectively assigning a
                    height after loading the SVG into the browser, instead of when creating it with
                    XSLT.</para>
            </listitem>
        </orderedlist>
        <para>These two approaches, each of which has advantages and disadvantages, are described in
            more detail and illustrated below.<footnote>
                <para>We are grateful to the developers who participated in the discussion we opened
                    about this topic in the xml.com Slack workspace, and especially Gerrit Imsieke
                    and Liam Quin. Slack postings are ephemeral, but although that conversation will
                    not be preserved, we are happy to be able to acknowledge it, more sustainably,
                    here.</para>
            </footnote></para>
        <section>
            <title>An XSLT approach</title>
            <section>
                <title>Overview</title>
                <para>The XSLT approach computes the dimensions of the text as it creates the SVG
                    and positions other elements accordingly. For horizontal or vertical text this
                    requires computing the length of the <code>&lt;text&gt;</code> and using it to
                    position other elements at a specific distance from it. This approach is less
                    precise than the JavaScript method described below for several reasons, but
                    because in our actual use we normally want to include a small amount of padding
                    around our <code>&lt;text&gt;</code> elements, we do not require placement with
                    exact precision.</para>
                <para>In the sample SVG below, we compute the length of the text using the method
                    described above and employ it to draw a line parallel to horizontal or vertical
                    text, so that we can examine the accuracy of our measurements visually.<footnote>
                        <para>Browsers interpret the values of the SVG
                                <code>@dominant-baseline</code> attribute inconsistently. See <xref
                                linkend="gudehus2021"/> for discussion, an interactive diagnostic
                            interface, and a suggested work-around.</para>
                    </footnote> (That is, the lines are not created as a font effect; the lines are
                    drawn independently of the text.) In the case of diagonal text we draw a
                    bounding rectangle. The third of the four examples in each figure is a null
                    string, so we expect to see no text and no line. The images below are in SVG
                    that is rendered in the browser, which means that the exact appearance may vary
                    depending on browser features:</para>
                <figure xml:id="horizontal-sample" xreflabel="Sample horizontal text">
                    <mediaobject>
                        <imageobject>
                            <imagedata width="12in" fileref="includes/horizontal-samples.svg"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <figure xml:id="vertical-sample" xreflabel="Sample vertical text">
                    <mediaobject>
                        <imageobject>
                            <imagedata width="12in" fileref="includes/vertical-samples.svg"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <figure xml:id="diagonal-sample" xreflabel="Sample diagonal text">
                    <mediaobject>
                        <imageobject>
                            <imagedata width="12in" fileref="includes/diagonal-samples.svg"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>The examples show the following desirable results:<itemizedlist>
                        <listitem>
                            <para>The overall precision is quite high.</para>
                        </listitem>
                        <listitem>
                            <para>A null string is correctly matched by a zero-length line.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>At the same time, these examples reveal several limitations. One limitation to
                    computing the dimensions of SVG <code>&lt;text&gt;</code> elements while
                    creating them is that <emphasis role="ital">user agents</emphasis> (typically
                    browsers) may impose small unpredictable modifications on the layout. For
                    example, the last of the horizontal examples above specifies a
                        <code>@font-size</code> of <code>"16"</code> (which is the SVG and CSS
                    default when no size is specified) and computes a length of 297.703125. However,
                    when when we open the SVG in Chrome, Firefox, and Safari and use the JavaScript
                        <code>getBBox()</code> method to query the size of the bounding box, the
                    three browsers report slightly different values for both height and width<footnote>
                        <para>We tested these examples under MacOS 11.3.1 (Big Sur) with Chrome
                            Version 90.0.4430.212 (Official Build) (x86_64), Firefox Developer
                            89.0b11 (64-bit), and Safari Version 14.1 (16611.1.21.161.6).</para>
                    </footnote><table>
                        <thead>
                            <tr>
                                <th>Browser</th>
                                <th>Height</th>
                                <th>Width</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Chrome</td>
                                <td>17.796875</td>
                                <td>297.703125</td>
                            </tr>
                            <tr>
                                <td>Firefox</td>
                                <td>18</td>
                                <td>298.3999938964844</td>
                            </tr>
                            <tr>
                                <td>Safari</td>
                                <td>17.734375</td>
                                <td>297.703125</td>
                            </tr>
                        </tbody>
                    </table> The retrieved length in Chrome and Safari matches the computed length,
                    but the value in Firefox does not.</para>
                <para>A second limitation to computing the dimensions of SVG
                        <code>&lt;text&gt;</code> elements while creating them is that the height of
                    an SVG <code>&lt;text&gt;</code> element is not fully predictable from its
                        <code>@font-size</code> attribute. In the table above, we see that none of
                    the browsers sets a height of 16 and each of them sets a different height from
                    the others.<footnote>
                        <para>The apparently widespread assumption that a <code>@font-size</code>
                            value specifies the vertical distance between baselines is incorrect
                            because, among other things, the actual spacing depends on the font
                            design, and not only on font size. See <xref linkend="deOliveira2017"/>
                            for details and discussion, as well as <xref linkend="chase2019"/>. In
                            principle it should be possible to extract the actual height from the
                            font metrics, as we do for character width, but we have not explored
                            that possibility for this report.</para>
                    </footnote></para>
                <para>A third limitation to computing the dimensions of SVG
                        <code>&lt;text&gt;</code> elements while creating them is that kerning
                    support in browsers is inconsistent, and user-controlled kerning support in SVG
                    and CSS is unreliable. Whether you see kerning applied in the horizontal,
                    vertical, and diagonal samples above will depend on your browser. The images
                    below are PNG screen captures of the three samples in the versions of Firefox
                    (left), Chrome (middle), and Safari (right) mentioned above. All three apply
                    kerning to the horizontal text; Firefox and Chrome also apply kerning to the
                    vertical and diagonal text, but Safari does not.</para>
                <figure xml:id="kerning-comparison" xreflabel="Kerning differences in browsers">
                    <mediaobject>
                        <imageobject>
                            <imagedata width="12in" fileref="includes/kerning-differences.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>SVG <code>&lt;text&gt;</code> elements may have a <code>@kerning</code>
                    attribute (although support for kerning is slated for removal from SVG 2<footnote>
                        <para>See <xref linkend="svg-2-kerning"/>.</para>
                    </footnote>) and CSS supports a <code>font-kerning</code> property. Browser
                    support for both of these features too inconsistent and unpredictable to be useful.<footnote>
                        <para>With no SVG <code>@kerning</code> attribute, with an SVG
                                <code>@kerning</code> attribute value of <code>"auto"</code> (the
                            default, which enables kerning), and an SVG <code>@kerning</code>
                            attribute value of <code>"0"</code> (disables kerning), kerning was
                            applied consistently to horizontal text in all three browsers and to
                            vertical (<code>@writing-mode="tb"</code>) in Firefox and Chrome, but
                            not in Safari. The CSS <code>font-kerning</code> property worked as
                            advertised in horizontal text in all three browsers, and had no effect
                            on vertical text in any of them: kerning was always applied to vertical
                            text in Firefox and Chrome and never applied to vertical text in
                            Safari.</para>
                    </footnote>
                </para>
                <para>In the horizontal butterfly chart below, the bars are labeled on the Y axis on
                    the right side, and a general label for the Y axis must be positioned to the
                    right of—but not too far to the right of—the longest bar label. Because we can
                    compute the lengths of the bar labels, we can find the length of the longest
                    bar, augment it with a predetermined amount of padding, and use that figure to
                    place the general Y axis label.</para>
                <figure xml:id="figure-01" xreflabel="Graph with horizontal bar labels">
                    <mediaobject>
                        <imageobject>
                            <imagedata width="12in" fileref="includes/horizontal-graph.svg"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>The vertical butterfly chart below illustrates a variant of the same task. In
                    this case we set <code>@writing-mode</code> to <code>"tb"</code> (top to bottom)
                    to create vertical text and use the longest bar label to compute the position
                    the general X axis label:</para>
                <figure xml:id="figure-01" xreflabel="Graph with vertical bar labels">
                    <mediaobject>
                        <imageobject>
                            <imagedata width="12in" fileref="includes/vertical-graph.svg"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>The strategy for positioning objects at a specific distance from rotated text
                    is similar to the strategy for vertical text, except that instead of using the
                    length of the diagonal text, we need to compute the vertical space it occupies.
                    We again start with vertical text and transform it by rotating it away from the
                    vertical with <code>transform="rotate()"</code>. <code>rotate()</code> takes
                    three arguments: the angle of rotation (in degrees) and the X and Y coordinates
                    of the center of rotation, which we map to the X and Y coordinates of the
                        <code>&lt;text&gt;</code> element.<footnote>
                        <para>This approach rotates the text around its starting position (left edge
                            and vertical center in this left-to-right example), so that the upper
                            left corner of the diagonal rendering protrudes slightly to the left and
                            top of the center of rotation, and the lower right corner behaves
                            similarly. Because we do not require high precision, we ignore these
                            protrusions.</para>
                    </footnote> If we regard the length of the text as the hypotenuse of a right
                    angle that has been rotated counter-clockwise away from true vertical, the
                    vertical height of the rotated text is the adjacent side of the right triangle,
                    which we can compute as <emphasis role="ital">hypotenuse * cosθ</emphasis>.<footnote>
                        <para>Inconveniently, SVG rotation requires that angles be expressed in
                            degrees, while XPath trigonometic functions in the <code>math:</code>
                            namespace require that they be expressed in radians. We convert degrees
                            to radians with <emphasis role="ital">radians = degrees * π /
                                180</emphasis>. The width of the text, should we need it, is the
                            opposite side of the angle, and its length can be determined as
                                <emphasis role="ital">hypotenuse * sinθ</emphasis>.</para>
                    </footnote> The graph with diagonal bar labels looks like:</para>
                <figure xml:id="figure-01" xreflabel="Graph with diagonal bar labels">
                    <mediaobject>
                        <imageobject>
                            <imagedata width="12in" fileref="includes/diagonal-graph.svg"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </section>
            <section>
                <title>Implementation</title>
                <para>Because this method requires knowing the widths of the individual glyphs while
                    constructing the SVG, we first extract width information from TrueType TTF files
                    and format them as XML using the script in <xref linkend="extract-widths"/>.<footnote>
                        <para>In its current form our script to extract glyph widths currently
                            processes only TTF fonts and fails on, for example, TTC and OTF. Because
                            these fonts also include metric information, if we need to process them
                            we could emend our script to process these filetypes, as well.</para>
                    </footnote> The output of the extraction process is an XML document that looks
                    like the following:</para>
                <programlisting language="xml" xml:space="preserve">&lt;metrics>
  &lt;metadata 
    fontName="Times New Roman" 
    fontPath="/System/Library/Fonts/Supplemental/Times New Roman.ttf" 
    fontSize="16"/>
  &lt;character dec="32" hex="0x20" name="space" str=" " width="4.0"/>
  &lt;character dec="33" hex="0x21" name="exclam" str="!" width="5.328125"/>
  &lt;!-- more characters -->
&lt;/metrics></programlisting>
                <para>We use the XPath <code>doc()</code> function to access this document (assigned
                    to the variable <code>$times-new-roman-16-mapping</code> in this case) from
                    within the XSLT that creates our SVG, and we compute the length (in SVG units)
                    of the text strings with the following XSLT function:</para>
                <programlisting language="xml">&lt;xsl:function name="djb:get-text-length" as="xs:double">
    &lt;xsl:param name="in" as="xs:string"/>
    &lt;xsl:sequence select="
            string-to-codepoints($in)
            ! codepoints-to-string(.)
            ! key('lengthByChar', ., $times-new-roman-16-mapping)/@width
            => sum()"/>
&lt;/xsl:function></programlisting>
                <para>This function explodes the string into a sequence of single-character strings,
                    looks up the widths of each of them in the mapping table extracted from the font
                    metrics, and sums the widths.</para>
            </section>
            <section>
                <title>Discussion</title>
                <section>
                    <title>Advantages</title>
                    <itemizedlist>
                        <listitem>
                            <para>SVG created in this way looks, both in raw form and when rendered,
                                like the SVG we would have created by specifying the positioning as
                                we did previously, that is, by using trial and error to identify
                                positioning values that produce acceptable layout and then
                                hard-coding them. This means that adopting the XSLT approach
                                described here does not require changing how we work with the
                                resulting SVG (which is not the case with the JavaScript approach,
                                about which please see below).</para>
                        </listitem>
                        <listitem>
                            <para>SVG created in this way does not depend on specific browser (or
                                other user-agent) behaviors. Except for unpredictable kerning (or
                                other automatic glyph-substitution behavior), SVG
                                    <code>&lt;text&gt;</code> elements placed with this method
                                should be positioned as reliably as non-text SVG elements, and the
                                method should continue to function with the browsers of the
                                future.</para>
                        </listitem>
                        <listitem>
                            <para>The XSLT-based method described here does not depend on a browser
                                or other DOM-and-JavaScript-aware environment to compute the
                                placement and positioning of SVG elements after the DOM content has
                                been loaded. This means that this method may be easier to use
                                outside browser environments.</para>
                        </listitem>
                        <listitem>
                            <para>Because creating SVG in this way does not require JavaScript
                                programming, it poses a lower barrier to entry for XML developers
                                who are not also comfortable with JavaScript development.<footnote>
                                    <para>We used Python to create XML font metrics files, but
                                        Python programming knowledge is not a requirement to access
                                        font metrics information inside font files. Among other
                                        things, there is an open-source stand-alone command-line
                                            <emphasis role="ital">ttx</emphasis> program that can
                                        export metric information from fonts as XML. See <xref
                                            linkend="ttx-intro"/> for more information.</para>
                                </footnote></para>
                        </listitem>
                    </itemizedlist>
                </section>
                <section>
                    <title>Disadvantages</title>
                    <itemizedlist>
                        <listitem>
                            <para>This approach requires prior preparation of font metric
                                information, an extra step that also has scalability implications
                                because changing decisions about font families, font sizes, or other
                                font properties requires creating separate additional metric
                                information for them. Over time developers might create libraries of
                                font metric information for reuse, but separate metric files will be
                                required for all combinations of font family and font size.</para>
                        </listitem>
                        <listitem>
                            <para>The method described above accesses only the glyph widths, which
                                represent a small part of the font metric information available from
                                a font file. A more robust and accurate implementation would
                                requires additional logic to deal with font effects (e.g., kerning,
                                ligatures, positional glyph variants) and transformations. That
                                information is present in the fonts, but the developer would have to
                                locate it in the font metric tables and then export it in a usable
                                format.</para>
                        </listitem>
                        <listitem>
                            <para>Because the metrics of system fonts may differ in unpredictable
                                ways (the most extreme of which would be the complete
                                non-availability of a font used to compute the size of a
                                    <code>&lt;text&gt;</code> element), developers may prefer to
                                rely on webfonts, which would need to be prepared and made
                                available. The approach described here is not compatible with font
                                stacks because font metrics cannot be expected to be the same across
                                fonts, including across fonts commonly stacked.</para>
                        </listitem>
                        <listitem>
                            <para>The description above works with TTF fonts, but has not been
                                tested with other font formats, such as OTF and TTC—let alone font
                                formats of the future.</para>
                        </listitem>
                    </itemizedlist>
                </section>
            </section>
        </section>
        <section>
            <title>A JavaScript approach</title>
            <section>
                <title>Overview</title>
                <para>The JavaScript approach leaves the SVG <code>@height</code> and
                        <code>@width</code> attributes unspecified if they cannot be computed at the
                    time the SVG is created. When the SVG is eventually loaded into a browser,
                    JavaScript functions compute the missing dimensions and write them into the DOM
                    in a way that controls the layout.</para>
                <para>Because the JavaScript approach relies on JavaScript applied in the browser
                    after the document loads, this method can be used only where the developer has
                    file system or server permissions needed to specify JavaScript modifications.
                    Because that is not the case with the Balisage <emphasis role="ital"
                        >Proceedings</emphasis> in which this report is being published, the output
                    of the JavaScript method is illustrated below with a PNG screen capture.<footnote>
                        <para>Our screen captures in this case are taken from the Firefox version
                            identified above, but we have verified that the method yields a
                            comparable rendering (except for cosmetic differences in browser
                            defaults) in Chrome and Safari.</para>
                    </footnote> The raw HTML, with embedded CSS and JavaScript, can be found in
                        <xref linkend="javascript-mockup"/>.</para>
                <figure xml:id="js-mockup" xreflabel="Sample output of JavaScript method">
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="includes/js-mockup.png" width="12in"/>
                        </imageobject>
                        <caption>
                            <para>Sample output of the JavaScript method. Colored outlines and
                                borders have been added to illustrate the positions of the otherwise
                                invisible bounding elements. Note that rotated text that crosses the
                                bounding box is rendered correctly (that is, not cropped).</para>
                        </caption>
                    </mediaobject>
                </figure>
            </section>
            <section>
                <title>Implementation</title>
                <para>Because we do not specify the width or height of the rectangular viewport of
                    our <code>&lt;svg&gt;</code> with explicit <code>@width</code> or
                        <code>@height</code> attributes, in absence of our JavaScript intervention
                    (see below) the <code>&lt;svg></code> elements will assume whatever the browser
                    assigns as default. The default size is implementation dependent, and therefore
                    unpredictable and unusable for our purposes.<footnote>
                        <para>As of 2017:<blockquote>
                                <para>The default size for HTML replaced elements will be used:
                                    300px wide, 150px tall. This applies for &lt;img>, &lt;object>
                                    or &lt;iframe>. The default 300×150 size also applies to inline
                                    &lt;svg> elements within HTML documents, but that’s a relatively
                                    recent consensus from the HTML5 specifications: other browsers
                                    will by default expand inline SVG to the full size of the
                                    viewport—equivalent to width: 100vw; height: 100vh; — which is
                                    the default size for SVG files that are opened directly in their
                                    own browser tab. Internet Explorer cuts the difference, using
                                    width of 100% and height of 150px for images and inline SVG.
                                        (<xref linkend="bellamy-royds2017"/>)</para>
                            </blockquote></para>
                    </footnote> Additionally, <code>&lt;svg&gt;</code> elements default to a CSS
                        <code>display</code> value of <code>inline-block</code>, which we have to
                    change to <code>block</code> to provide more transparent control over explicit
                    positioning.</para>
                <para>Our general strategy relies on HTML and CSS Flexbox to manage the layout of
                    the SVG components. For this purpose what would normally be constructed as a
                    single SVG document (e.g., a bar graph with all of its labels) is divided into
                    multiple SVG documents, each wrapped in an HTML <code>&lt;div&gt;</code> or
                    other block-level element. We use CSS Flexbox to position the
                        <code>&lt;div&gt;</code> elements as they would have been positioned in a
                    single, unified SVG document.</para>
                <para>We illustrate our positioning strategy in the image above. In that image the
                        <code>&lt;body&gt;</code> contains three <code>&lt;section&gt;</code>
                    elements, one for each of the horizontal rows (outlined in red). The
                        <code>display</code> property of the <code> &lt;body&gt;</code> is set to
                        <code>flex</code> with a <code>flex-direction</code> value of
                        <code>column</code>, so that the <code>&lt;section&gt;</code> elements will
                    be rendered from top to bottom in the browser window. The height of an HTML
                        <code>&lt;section&gt;</code> is, unless specified explicitly in other ways,
                    determined by its contents, and we use JavaScript to write <code>@height</code>
                    attributes into the <code>&lt;svg&gt;</code> descendants of each
                        <code>&lt;section&gt;</code> that actual match the height occupied by the
                    SVG. Once those attributes have been added, the height of a section will be
                    determined by the height of the <code>&lt;svg&gt;</code> it contains. We use the
                    CSS <code>row-gap</code> property to introduce a gutter between the
                    sections.</para>
                <para>Each of the three <code>&lt;section&gt;</code> elements also has its
                        <code>display</code> property set to <code>flex</code>, this time with a
                        <code>flex-direction</code> value of <code>row</code>, so that its
                        <code>&lt;div&gt;</code> children will be distributed horizontally across
                    the row. We use the CSS <code>column-gap</code> property to introduce a gutter
                    between the <code>&lt;div&gt;</code> elements in each row (each HTML
                        <code>&lt;section&gt;</code>). Once our JavaScript writes
                        <code>@width</code> attributes into the SVG descendants of each
                        <code>&lt;div&gt;</code>, the <code>&lt;div&gt;</code> will occupy the space
                    required for their SVG contents, overriding the default width that would
                    otherwise be supplied by the browser.</para>
                <para>The JavaScript that supplies explicit <code>@width</code> and
                        <code>@height</code> values to the <code>&lt;svg&gt;</code> elements
                    is:</para>
                <programlisting language="javascript">window.addEventListener('DOMContentLoaded', init, false);
function init() {
    const divs = document.querySelectorAll('div');
    for (i = 0; i &lt; divs.length; i++) {
        bb = divs[i].querySelector('g').getBBox();
        console.log(bb);
        divs[i].querySelector('svg').setAttribute('height', bb.height);
        divs[i].querySelector('svg').setAttribute('width', bb.width);
    }
}</programlisting>
                <para>Our sample takes advantage of use of <code>&lt;div&gt;</code> elements only as
                    wrappers for SVG content, and of our placement of only a single SVG
                        <code>&lt;g&gt;</code> element inside each <code>&lt;svg&gt;</code> element.
                    HTML structured differently may require adjustments, but the general principle
                    would be the same: use the JavaScript <code>getBBox()</code> method to determine
                    the size of the bounding box for each SVG component and write the width and
                    height into the <code>&lt;svg&gt;</code> wrapper element as <code>@width</code>
                    and <code>@height</code> attribute values.</para>
            </section>
            <section>
                <title>Discussion</title>
                <section>
                    <title>Advantages</title>
                    <itemizedlist>
                        <listitem>
                            <para>The biggest advantage of the JavaScript approach is that it does
                                not require the preparation of font metric information in advance,
                                which is a benefit both initially and with respect to
                                scalability.</para>
                        </listitem>
                        <listitem>
                            <para>The JavaScript approach adapts to the viewing environment because
                                it reads the actual dimensions of the SVG objects after their
                                rendering information has been computed by the browser. This means
                                that the dimensions will be correct for any font, including system
                                fonts and fonts determined with a font stack.</para>
                        </listitem>
                        <listitem>
                            <para>Also because the JavaScript approach has access to the actual
                                rendered dimensions, it does not require additional logic (beyond
                                width as specified in the font metrics) to deal with font effects
                                (e.g., ligatures, positional glyph variants). The
                                    <code>getBBox()</code> method computes width and height after
                                any such font adjustments have been applied.</para>
                        </listitem>
                    </itemizedlist>
                </section>
                <section>
                    <title>Disadvantages</title>
                    <itemizedlist>
                        <listitem>
                            <para>The JavaScript approach equires JavaScript programming knowledge,
                                which cannot be assumed for all XML-stack developers, and the same
                                is true with respect to knowledge of CSS Flexbox. The actual CSS and
                                JavaScript required is light and the examples provided here can
                                serve as models, but both the CSS and JavaScript used here will
                                typically have to be adjusted according to the specific structures
                                employed in individual projects.</para>
                        </listitem>
                        <listitem>
                            <para>Because we rely on HTML and CSS to support the relative
                                positioning of the SVG components of what is conceptually a single
                                image, this method is not, at least as implemented here, suited for
                                not appropriate for the creation of stand-alone SVG.</para>
                        </listitem>
                    </itemizedlist>
                </section>
            </section>
        </section>
    </section>
    <section>
        <title>Loose ends and future directions</title>
        <para>Our XSLT approach assumes that the font metrics that can be extracted from the font
            files are sufficient to compute the length of an SVG line of text. Our implementation
            does not attempt to access kerning information, and it has not been tested on writing
            systems that involve character substitution (including positional glyph variation or
            ligation) or glyph reordering. We have confirmed that our XSLT approach is not impacted
            negatively by zero-width characters as long as the font metrics for those glyphs
            correctly report a width of zero, as is the case with the Times New Roman font that we
            used for testing and illustration.</para>
        <para>Saxon-JS relies on a JavaScript implementation of the Saxon XSLT engine that is
            designed to perform transformations inside the browser. Insofar as Saxon-JS incorporates
            both XSLT and JavaScript functionality, it may provide a cleaner integration of the two
            approaches. We do not explore this approach here.</para>
        <para>Our definition of the problem to be solved presumes that an algorithmic solution is
            appropriate. Our experimentation above confirms that we can ask XSLT or JavaScript to
            compute the dimensions of SVG <code>&lt;text&gt;</code> elements, dimensions that we had
            previously regarded as unknowable, and we can use that information to automate the
            placement of other SVG components that must be positioned in ways that depend on the
            dimensions of <code>&lt;text&gt;</code> elements. At the same time, algorithmic layout
            as implemented here is a crude method because it is not sensitive to context-specific
            details. For example, we have assumed that the general labels on X and Y axes should be
            positioned not too close to and not too far from the longest data labels on those axes,
            but those assumptions, although self-evidently correct, are insufficient. In practice we
            might want to customize the positioning according to specific features of the data,
            e.g., by labeling an axis in a way that is closer than the distance dictated by the
            longest data label, but that happens not to overlap that label. This sort of detail is
            computable in principle, ADD EXAMPLE AND DISCUSS </para>
    </section>
    <section>
        <title>Conclusion</title>
        <para>The goal of this report has been to identify strategies for working around the fact
            that SVG <code>&lt;text&gt;</code> elements do not know their length, which makes it
            difficult to position other elements in relationship to them without a tedious
            trial-and-error approach. We have identified, implemented, illustrated, and discussed
            two approaches to meeting this need, one in XSLT and one in JavaScript. Each of these
            approaches has its own advantages and disadvantages, but both have been shown to work,
            at least with the authentic examples used here. We have identified some limitations and
            some directions for future improvement, but both methods provide realisitic alternatives
            to guesswork, trial-and-error, and magic numbers.</para>
    </section>
    <appendix xml:id="extract-widths" xreflabel="Appendix A">
        <title>Script to extract font widths as XML</title>
        <para>The following Python script exports the widths of all glyphs in a TrueType font. The
            script has two positional arguments, a required path to the font and an optional point
            size (defaults to 16, which is the size of SVG text that either does not specify a
                <code>@font-size</code> or specifies a size of <code>"medium"</code>.</para>
        <programlisting language="python" xml:space="preserve">#!/usr/bin/env python
# https://stackoverflow.com/questions/4190667/how-to-get-width-of-a-truetype-font-character-in-1200ths-of-an-inch-with-python
# https://fonttools.readthedocs.io/en/latest/index.html
# https://www.geeksforgeeks.org/create-xml-documents-using-python/
# https://stackoverflow.com/questions/678236/how-to-get-the-filename-without-the-extension-from-a-path-in-python
from fontTools.ttLib import TTFont
from fontTools.ttLib.tables._c_m_a_p import CmapSubtable
from xml.dom import minidom
from matplotlib import font_manager
from pathlib import Path
import argparse

import pprint
pp = pprint.PrettyPrinter(indent=2)

# Validate fontname
# https://stackoverflow.com/questions/15203829/python-argparse-file-extension-checking
def validateFont(fontName):
    """Find full font system path from bare name (without extensions)"""
    installed_fonts = {Path(item).stem: item for item in font_manager.findSystemFonts()}
    return installed_fonts.get(fontName) # returns None on KeyError

def allInstalledFonts():
    """Report all available fonts if user supplies erroneous value"""
    installed_fonts = {Path(item).stem: item for item in font_manager.findSystemFonts()}
    return sorted(installed_fonts.keys())

# Handle command line arguments: font name and optional size
parser = argparse.ArgumentParser()
parser.add_argument("ttf", help="TrueType font name without extension (quote names with spaces)")
parser.add_argument("size", help="size in points (defaults to 16pt)", type=int, nargs="?", default=16)
args = parser.parse_args()
fontName = args.ttf
size = args.size
fontPath = validateFont(fontName) # returns None for erroneous value

if not fontPath: # bail out if font not found
    print(f"Font '{fontName}' not found. Legal fontnames are:")
    pp.pprint(allInstalledFonts())
    quit()

# from StackOverflow
font = TTFont(fontPath, fontNumber=0) # BUG: breaks on ttc, even with fontNumber; table is different?
cmap = font['cmap']
t = cmap.getcmap(3,1).cmap # map of decimal values to glyph names
s = font.getGlyphSet()
units_per_em = font['head'].unitsPerEm

def getTextWidth(text,pointSize):
    total = 0
    for c in text:
        if ord(c) in t and t[ord(c)] in s:
            total += s[t[ord(c)]].width
        else:
            total += s['.notdef'].width
    total = total*float(pointSize)/units_per_em;
    return total

# from minidom documentation
root = minidom.Document()
xml = root.createElement('metrics')
root.appendChild(xml)
metadata = root.createElement('metadata')
metadata.setAttribute('fontName', fontName)
metadata.setAttribute('fontPath', fontPath)
xml.appendChild(metadata)

c_dict = dict()
for num_dec in range(65535): # entire BMP; decimal Unicode value
    char = chr(num_dec) # character as string
    c_dict[char]= getTextWidth(char, size) # default SVG font-size is 16 (medium)

for item in c_dict.items(): # string-value : width
    char = item[0] # string value of character
    num_dec = ord(char) # Unicode value (decimal)
    num_hex = hex(num_dec) # Unicode value (hex)
    width = item[1] # glyph width
    if num_dec in t: # not all values are present in font
        name = t[num_dec] # look up name by decimal value
        e = root.createElement('character')
        e.setAttribute('str', str(char)) # attribute have to be set as strings
        e.setAttribute('dec', str(num_dec))
        e.setAttribute('hex', str(num_hex))
        e.setAttribute('width', str(width))
        e.setAttribute('name', name)
        xml.appendChild(e)

# serialize and render XML
xml_str = root.toprettyxml(indent="  ")
print(xml_str)</programlisting>
        <para>The output is an XML document that looks like the following:</para>
        <programlisting language="xml" xml:space="preserve">&lt;metrics>
  &lt;metadata 
    fontName="Times New Roman" 
    fontPath="/System/Library/Fonts/Supplemental/Times New Roman.ttf" 
    fontSize="16"/>
  &lt;character dec="32" hex="0x20" name="space" str=" " width="4.0"/>
  &lt;character dec="33" hex="0x21" name="exclam" str="!" width="5.328125"/>
  &lt;!-- more characters -->
&lt;/metrics></programlisting>
        <para>The SVG layout strategy described here uses the <code>@str</code> value to retrieve
            the <code>@width</code> value. The <code>@dec</code> (decimal) and <code>@hex</code>
            (hexadecimal) values are not currently used.</para>
    </appendix>
    <appendix xml:id="javascript-mockup" xreflabel="Appendix B">
        <title>Sample HTML for JavaScript method</title>
        <programlisting language="xml" xml:space="preserve">
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;!DOCTYPE html>
&lt;html xmlns="http://www.w3.org/1999/xhtml">
  &lt;!-- ================================================================ -->
  &lt;!-- Illustrates JavaScript mediated layout of SVG &lt;text>             -->
  &lt;!--                                                                  -->
  &lt;!-- &lt;body> has &lt;section> children arranged vertically and outlined   -->
  &lt;!--   in red                                                         -->
  &lt;!-- &lt;section> elements have &lt;div> children arranged horizontally     -->
  &lt;!--   and bordered in blue                                           -->
  &lt;!-- ================================================================ -->
  &lt;head>
    &lt;title>JavaScript method mockup&lt;/title>
    &lt;style type="text/css">
      svg {
        display: block;
        overflow: visible; # for tightly rotated text
      }
      body {
        display: flex;
        flex-direction: column;
        row-gap: 1em;
      }
      section {
        display: flex;
        flex-direction: row;
        column-gap: 1em;
        outline: 4px red solid;   
      }
      div {
        border: 2px blue solid;
      }&lt;/style>
    &lt;script type="text/javascript">
      &lt;![CDATA[
      window.addEventListener('DOMContentLoaded', init, false);
      function init() {
        const divs = document.querySelectorAll('div');
        for (i = 0; i &lt; divs.length; i++) {
          bb = divs[i].querySelector('g').getBBox();
          console.log(bb);
          divs[i].querySelector('svg').setAttribute('height', bb.height);
          divs[i].querySelector('svg').setAttribute('width', bb.width);
        }
      }//&#x005d;&#x005d;>&lt;/script>
  &lt;/head>
  &lt;body>
    &lt;section>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" font-family="Times New Roman" font-size="16"
              dominant-baseline="middle" dy=".5em">Sample horizontal text&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" writing-mode="tb" font-family="Times New Roman"
              font-size="16" dominant-baseline="middle" dx=".5em">Sample vertical
              text&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" writing-mode="tb" font-family="Times New Roman"
              font-size="16" transform="rotate(-30)">Sample diagonal text (30º)&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" writing-mode="tb" font-family="Times New Roman"
              font-size="16" transform="rotate(-60)">Sample diagonal text (60º)&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" font-family="Times New Roman" font-size="16"
              dominant-baseline="middle" dy=".5em">Sample horizontal text&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
    &lt;/section>
    &lt;section>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" font-family="Times New Roman" font-size="16"
              dominant-baseline="middle" dy=".5em">Sample horizontal text&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" writing-mode="tb" font-family="Times New Roman"
              font-size="16" dominant-baseline="middle" dx=".5em">Sample vertical
              text&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" writing-mode="tb" font-family="Times New Roman"
              font-size="16" transform="rotate(-30)">Sample diagonal text (30º)&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" writing-mode="tb" font-family="Times New Roman"
              font-size="16" transform="rotate(-60)">Sample diagonal text (60º)&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" font-family="Times New Roman" font-size="16"
              dominant-baseline="middle" dy=".5em">Sample horizontal text&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
    &lt;/section>
    &lt;section>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" font-family="Times New Roman" font-size="16"
              dominant-baseline="middle" dy=".5em">Sample horizontal text&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" writing-mode="tb" font-family="Times New Roman"
              font-size="16" dominant-baseline="middle" dx=".5em">Sample vertical
              text&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" writing-mode="tb" font-family="Times New Roman"
              font-size="16" transform="rotate(-30)">Sample diagonal text (30º)&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" writing-mode="tb" font-family="Times New Roman"
              font-size="16" transform="rotate(-60)">Sample diagonal text (60º)&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
      &lt;div>
        &lt;svg xmlns="http://www.w3.org/2000/svg">
          &lt;g>
            &lt;text x="0" y="0" font-family="Times New Roman" font-size="16"
              dominant-baseline="middle" dy=".5em">Sample horizontal text&lt;/text>
          &lt;/g>
        &lt;/svg>
      &lt;/div>
    &lt;/section>
  &lt;/body>
&lt;/html>

        </programlisting>
    </appendix>
    <bibliography>
        <title>Works cited</title>
        <bibliomixed xml:id="ttx-intro" xreflabel="An intro to FontTools"><quote>An intro to
                FontTools.</quote>
            <link>https://github.com/arrowtype/fonttools-intro</link></bibliomixed>
        <bibliomixed xml:id="bellamy-royds2017" xreflabel="Bellamy-Royds 2017"><quote>How to scale
                SVG.</quote> Updated on Jun 27, 2017.
            <link>https://css-tricks.com/scale-svg/</link></bibliomixed>
        <bibliomixed xml:id="chase2019" xreflabel="Chase 2019">Chase, William R. <quote>Font height
                differences between Windows and Mac.</quote> 2019.
                <link>https://www.williamrchase.com/post/font-height-differences-between-windows-and-mac/</link></bibliomixed>
        <bibliomixed xml:id="deOliveira2017" xreflabel="De Oliveira 2017">De Oliveira, Vincent.
                <quote>Deep dive CSS: font metrics, line-height and vertical-align.</quote> 2017.
                <link>https://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align</link></bibliomixed>
        <bibliomixed xml:id="gudehus2021" xreflabel="Gudehus 2021">Gudehus, Benjamin.
                <quote>Vertical text alignment in SVG.</quote>
            <link>https://observablehq.com/@hastebrot/vertical-text-alignment-in-svg</link></bibliomixed>
        <!--<bibliomixed xml:id="getBoundingClientRect" xreflabel="MDN getBoundingClientRect()"
                ><quote>Element.getBoundingClientRect()</quote>, MDN Web Docs,
                <link>https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect</link>
        </bibliomixed>-->
        <!--<bibliomixed xml:id="getBBox" xreflabel="MDN getBBox()"
                ><quote>SVGGraphicsElement.getBBox()</quote>, MDN Web Docs,
                <link>https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox</link>
        </bibliomixed>-->
        <!--<bibliomixed xml:id="primer-getBoundingClientRect"
            xreflabel="MDN getBoundingClientRect() (Primer)"><quote>getBBox</quote>. <emphasis
                role="ital">An SVG primer for today’s browsers. W3C Working Draft — September
                2010</emphasis>, ed. David Dailey.
                <link>https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#getBBox</link>
        </bibliomixed>-->
        <!--<bibliomixed xml:id="primer-getCTM" xreflabel="MDN getCTM() (Primer)"
                ><quote>getCTM()</quote>. <emphasis role="ital">An SVG primer for today’s browsers.
                W3C Working Draft — September 2010</emphasis>, ed. David Dailey.
                <link>https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#getCTM</link>
        </bibliomixed>-->
        <bibliomixed xml:id="svg-2-kerning" xreflabel="SVG 2.0, Kerning">Scalable Vector Graphics
            (SVG) 2 W3C Candidate Recommendation 04 October 2018. §11.10.1.4. The ‘kerning’
            property.
            <link>https://www.w3.org/TR/SVG2/text.html#KerningProperty</link></bibliomixed>
    </bibliography>
</article>
