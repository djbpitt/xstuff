<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="balisage-author.css"?>
<?xml-model href="../Balisage-1-5-rng/balisage-1-5.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0-subset Balisage-1.5">
    <title>How long is my SVG <code>&lt;text&gt;</code> element?</title>
    <info>
        <abstract>
            <para>BLAH BLAH BLAH</para>
        </abstract>
        <author>
            <personname>
                <firstname>David</firstname>
                <othername>J.</othername>
                <surname>Birnbaum</surname>
            </personname>
            <personblurb>
                <para>David J. Birnbaum is Professor of Slavic Languages and Literatures at the
                    University of Pittsburgh. He has been involved in the study of electronic text
                    technology since the mid-1980s, has delivered presentations at a variety of
                    digital humanities and electronic text technology conferences, and has served on
                    the board of the Association for Computers and the Humanities, the editorial
                    board of <emphasis role="ital">Markup languages: theory and practice</emphasis>,
                    and the Text Encoding Initiative Technical Council. Much of his electronic text
                    work intersects with his research in medieval Slavic manuscript studies, but he
                    also often writes about issues in the philosophy of markup. For the past ten
                    years he has been teaching an XML-oriented course in the University Honors
                    College at the University of Pittsburgh entitled <quote>Computational methods in
                        the humanities</quote> (<link>http://dh.obdurodon.org</link>).</para>
            </personblurb>
            <affiliation>
                <orgname>University of Pittsburgh</orgname>
            </affiliation>
            <email>djbpitt@gmail.com</email>
            <link>http://www.obdurodon.org</link>
        </author>
        <author>
            <personname>
                <!-- Middle  name? Other name parts or shapes? -->
                <firstname>Charlie</firstname>
                <surname>Taylor</surname>
            </personname>
            <personblurb>
                <para>BLAH BLAH BLAH</para>
            </personblurb>
            <affiliation>
                <!-- job title is optional -->
                <orgname>University of Pittsburgh</orgname>
            </affiliation>
            <email>[ADD EMAIL]</email>
            <link>[ADD LINK(s)?]</link>
        </author>
        <keywordset role="author">
            <keyword>SVG</keyword>
            <keyword>font metrics</keyword>
        </keywordset>
    </info>
    <section xml:id="intro">
        <title>The problem</title>
        <para>SVG layout requires that the developer be in control of the dimensions of the objects
            that must be placed in the coordinate space. It is easy to specify (or compute based on
            other specifications) the size (bounding box height and width) of many SVG objects
            (rectangles, circles, lines), identifying the bounding box for text is challenging
            because SVG text does not know its own length. Developers are able to specify a
            font-size, which corresponds to the height of the font (from baseline to baseline)<footnote>
                <para>If the user does not specify a font size, the default is 16 pixels, which
                    corresponds to specifying the value <code>"medium"</code> for a
                        <code>@font-size</code> attribute on the SVG <code>&lt;text&gt;</code>
                    element. The <code>@font-size</code> setting may be modified before rendering
                    with the global SVG <code>@transform</code> attribute.</para>
            </footnote>, but the length of a string of characters depends on the widths of the
            individual characters, and those widths are not exposed in any convenient, accessible
            way in a regular XML development environment.</para>
        <para>Our test case for exploring and addressing this challenge is an SVG bar graph like the following:<footnote>
                <para>This graph is based on XML originally prepared by Matthew Borbonus, Kyle
                    Huber, and Ethan Moser as part of their <emphasis role="ital">Tracking language
                        of catch and release in the poetical corpus of Edgar Allan Poe</emphasis>
                        (<link>http://poe.obdurodon.org/</link>,
                        <link>https://github.com/Ethandaniel47/EdgarAllanPoeProject</link>). The
                    developers tagged parts of speech (e.g., <code>&lt;noun&gt;</code>,
                        <code>&lt;verb&gt;</code>, etc.) in a small corpus of Poe’s poetry, adding
                    an attribute <code>@value</code> to those elements with values of
                        <code>"open"</code> and <code>"closed"</code> according to whether the
                    tagged words could be associated with openness or closedness. We have adapted
                    the XML and schema from the original project for this report, and the SVG
                    visualizations are our own.</para>
            </footnote></para>
        <figure xml:id="figure-01" xreflabel="Sample bar graph">
            <mediaobject>
                <imageobject>
                    <imagedata fileref="includes/Bal2021birn0505_svg-01.svg"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>In this graph the bars rest on the X axis, and they bear individual slanted labels
            below. Under those labels we label the X axis itself. The challenge involves determining
            the Y position of the <quote>Poem</quote> label for the X axis, since that position will
            depend on the length of the longest bar label, and will therefore vary according to the
            specific poem titles. If you are like us, you place that label with a combination of
            guesswork with trial and error and then hard-code a magic number, which—predictably and
            understandably—breaks as soon as you try to reuse the code with new input.<footnote>
                <para>Placing the X axis label more precisely in a way that takes into account the
                    lengths and positions of all of the bar labels is a version of the same type of
                    task, although it is a much more complicated version. For example, if the
                    leftmost and rightmost bar labels are the longest, a human designer might choose
                    to label the X axis, if it is short enough, slightly between them, instead of
                    fully below them. Similarly, a human designer might choose, if the bar labels
                    happen to be longer on one side of the graph than the other, to place the axis
                    label on the shorter side, below the bar labels on that side, but not below the
                    longest label (on the other side).</para>
                <para>Our modest goal is simply to place the general label for the X axis with
                    reliable precision below the longest bar label. Whether the more exact placement
                    described above would be worth the extra effort is less clear, but, as will be
                    clear from the description below, it can be implemented as an extension of our
                    simpler solution to the simpler task.</para>
            </footnote></para>
    </section>
    <section xml:id="solutions">
        <title>Solutions</title>
        <para> This presentation explores two strategies for working around the difficulty of
            knowing the length of an SVG <code>&lt;text></code> element:</para>
        <orderedlist>
            <listitem>
                <para>As a preprocessing step before undertaking the transformation that outputs the
                    SVG bar graph, create a mapping between characters and their individual widths
                    by extracting font metrics. We can then import that mapping into the XSLT that
                    generates the SVG and it to compute the length of text strings. If the text
                    strings are horizontal or vertical, the length is one of the dimensions of the
                    bounding box, and the other dimension is the font size. If the text is rotated,
                    we can use the length combined with the angle of rotation to compute the
                    dimensions of the bounding box. </para>
            </listitem>
            <listitem>
                <para>Output SVG components that must be stacked vertically as separate
                        <code>&lt;svg&gt;</code> elements with no height specified. These would
                    wind up with a default height in a browser that would be wrong initially. We
                    then use CSS Flexbox to stack the <code>&lt;svg&gt;</code> elements vertically,
                    and employ the JavaScript <code>element.getBBox()</code> function to compute the
                    dimensions of the bounding box for each of the vertically stacked
                        <code>&lt;svg&gt;</code> elements. We can then write the computed height
                    values into those elements in the DOM, effectively assigning a height after
                    loading the SVG into the browser, instead of when creating it with XSLT.</para>
            </listitem>
        </orderedlist>
        <para>These two approaches are described in more detail and illustrated below.<footnote>
                <para>We are grateful to the developers who participated in the discussion we opened
                    about this topic in the xml.com Slack workspace, and especially Gerrit Imsieke
                    and Liam Quin. Slack postings are ephemeral, but although that conversation will
                    not be preserved, we are happy to be able to acknowledge it, more persistently,
                    here.</para>
            </footnote></para>
        <section>
            <title>An XSLT approach</title>
            <section>
                <title>Overview</title>
                <para>The XSLT approach computes the dimensions of the text as it creates the SVG
                    and positions other elements in relation to <code>&lt;text&gt;</code> elements
                    accordingly. For horizontal or vertical text this requires computing the length
                    of the <code>&lt;text&gt;</code> and using it to position other elements at a
                    specific distance from the end of the text. This approach is less precise than
                    the JavaScript method described below for at least two reasons (see below), but
                    because we normally want to include a small amount of padding around our
                        <code>&lt;text&gt;</code> elements in any case, we do not require high
                    precision.</para>
                <para>In the sample SVG below, we compute the length of the text using the method
                    described here and employ it to draw a line parallel to horizontal or vertical
                    text, so that we can assess the accuracy of our measurements visually. In the
                    case of diagonal text we draw a bounding rectangle. The third of the four
                    examples in each figure is a null string:</para>
                <figure xml:id="horizontal-sample" xreflabel="Sample horizontal text">
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="includes/horizontal-samples.svg"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <figure xml:id="vertical-sample" xreflabel="Sample vertical text">
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="includes/vertical-samples.svg"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <figure xml:id="diagonal-sample" xreflabel="Sample diagonal text">
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="includes/diagonal-samples.svg"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>The examples show the following desirable results:<itemizedlist>
                        <listitem>
                            <para>The overall precision is quite high.</para>
                        </listitem>
                        <listitem>
                            <para>A null string is correctly matched by a zero-length line.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>One limitation to computing the dimensions of SVG <code>&lt;text&gt;</code>
                    elements while creating them is that <emphasis role="ital">user
                        agents</emphasis> (typically browsers) may impose small unpredictable
                    modifications on the layout. For example, the last of the horizontal examples
                    above specifies a <code>@font-size</code> or <code>"16"</code> and computes a
                    length of 297.703125), but when we open the SVG in Chrome, Firefox, and Safari
                    and use the JavaScript <code>getBBox()</code> method to query the size of the
                    bounding box, the three browsers report slightly different values for both
                    height and width:<footnote>
                        <para>We tested under MacOS 11.3.1 (Big Sur) with Chrome Version
                            90.0.4430.212 (Official Build) (x86_64), Firefox Developer 89.0b11
                            (64-bit), and Safari Version 14.1 (16611.1.21.161.6).</para>
                    </footnote><table>
                        <thead>
                            <tr>
                                <th>Browser</th>
                                <th>Height</th>
                                <th>Width</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Chrome</td>
                                <td>17.796875</td>
                                <td>297.703125</td>
                            </tr>
                            <tr>
                                <td>Firefox</td>
                                <td>18</td>
                                <td>298.3999938964844</td>
                            </tr>
                            <tr>
                                <td>Safari</td>
                                <td>17.734375</td>
                                <td>297.703125</td>
                            </tr>
                        </tbody>
                    </table></para>
                <para>A second limitation to computing the dimensions of SVG
                        <code>&lt;text&gt;</code> elements while creating them is that the height is
                    not fully predictable from the <code>@font-size</code> attribute of the
                        <code>&lt;text&gt;</code> element. In the table above, we see that none of
                    the browsers sets a height of 16 and each of them sets a different height.<footnote>
                        <para>The widespread assumption that the <code>@font-size</code> values
                            specifies the vertical distance between baselines is incorrect because,
                            among other things, the values depend on font metrics, and not only on
                            font size. See <xref linkend="deOliveira2017"/> for details and
                            discussion. It should be possible to extract the actual height from the
                            font metrics, as we do for character width, but we have not explored
                            that possibility for this report.</para>
                    </footnote></para>
                <para>A third limitation to computing the dimensions of SVG
                        <code>&lt;text&gt;</code> elements while creating them is that kerning
                    support in browsers is inconsistent, and user-controlled kerning support in SVG
                    and CSS is unreliable. </para>
                <para>In the horizontal butterfly chart below, the bars are labeled on the Y axis on
                    the right side, and a general label for the Y axis must be positioned to the
                    right of—but not too far to the right of—the longest bar label. Because we can
                    compute the lengths of the bar labels, we can find the length of the longest
                    bar, augment it with a predetermined amount of padding, and use that figure to
                    place the general Y axis label.</para>
                <figure xml:id="figure-01" xreflabel="REPLACE WITH REAL IMAGE">
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="includes/Bal2021birn0505_svg-01.svg"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>The vertical butterfly chart below illustrates a variant of the same task. In
                    this case we set <code>@writing-mode</code> to <code>"tb"</code> (top to bottom)
                    to create vertical text and use the longest bar label to compute the position
                    the general X axis label:</para>
                <figure xml:id="figure-01" xreflabel="REPLACE WITH REAL IMAGE">
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="includes/Bal2021birn0505_svg-01.svg"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>The strategy for positioning objects at a specific distance from rotated text
                    is similar, except that instead of using the length of the <emphasis role="ital"
                        >diagonal</emphasis> text, we need to compute the <emphasis role="ital"
                        >vertical</emphasis> space it occupies. We again start with vertical text
                    and transform it by rotating it away from the vertical with
                        <code>transform="rotate()"</code>. <code>rotate()</code> takes three
                    arguments: the angle of rotation (in degrees) and the X and Y coordinates of the
                    center of rotation, which we map to the X and Y coordinates of the
                        <code>&lt;text&gt;</code> element.<footnote>
                        <para>This approach rotates what was originally left-to-right text around
                            its left edge and vertical center, so that the upper left corner of the
                            diagonal rendering protrudes slightly to the left and top of the center
                            of rotation, and the lower right corner behaves similarly. Because we do
                            not require high precision, we ignore these protrusions.</para>
                    </footnote> If we regard the length of the text as the hypotenuse of a right
                    angle, the vertical height of the text is the adjacent side, which we can
                    compute as <emphasis role="ital">hypotenuse * cosθ</emphasis> .<footnote>
                        <para>Inconveniently, SVG rotation requires that angles be expressed in
                            degrees, while XPath trigonometic functions in the <code>math:</code>
                            namespace require that they be expressed in radians. We convert degrees
                            to radians with <emphasis role="ital">radians = degrees *
                                π/180</emphasis>. The width of the text, should we need it, is side
                            opposite the angle, and its length can be determined as <emphasis
                                role="ital">opposite = hypotenuse * sinθ</emphasis>.</para>
                    </footnote></para>
            </section>
            <section>
                <title>Implementation</title>
                <para>Because this method requires knowing the widths of the individual glyphs while
                    constructing the SVG, we first extract width information from TrueType TTF files
                    and format them as XML using the script in <xref linkend="extract-widths"/>.<footnote>
                        <para>In its current form our script to extract glyph widths currently
                            processes only TTF fonts; it fails on, for example, TTC and OTF.</para>
                    </footnote> The output is an XML document that looks like the following:</para>
                <programlisting language="xml" xml:space="preserve">&lt;metrics>
  &lt;metadata 
    fontName="Times New Roman" 
    fontPath="/System/Library/Fonts/Supplemental/Times New Roman.ttf" 
    fontSize="16"/>
  &lt;character dec="32" hex="0x20" name="space" str=" " width="4.0"/>
  &lt;character dec="33" hex="0x21" name="exclam" str="!" width="5.328125"/>
  &lt;!-- more characters -->
&lt;/metrics></programlisting>
                <para>We use the XPath <code>doc()</code> function to access this document inside
                    the XSLT (assigned to the variable <code>$times-new-roman-16-mapping</code> in
                    this case) that creates our SVG, and we compute the length (in SVG units) of the
                    text strings with the following XSLT function:</para>
                <programlisting>xsl:function name="djb:get-text-length" as="xs:double">
    xsl:param name="in" as="xs:string"/>
    xsl:sequence select="
            string-to-codepoints($in)
            ! codepoints-to-string(.)
            ! key('lengthByChar', ., $times-new-roman-16-mapping)/@width
            => sum()"/>
/xsl:function></programlisting>
            </section>
            <section>
                <title>Discussion</title>
                <para>Pro: Output does not depend on viewing in a browser or other
                    DOM-and-JavaScript-aware environment. For example, can be included as an image
                    in a Balisage (Docbook-based) document. Requires only XML-based programming; in
                    particular, does not require JavaScript knowledge.</para>
                <para>Con: Requires preparation of font metric information, an extra step both
                    initially and with scaling consequences (e.g., user cannot safely override
                    supplied font information). For improved robustness, requires webfont. Requires
                    additional logic to deal with font effects (e.g., kerning<footnote>
                        <para>Kerning is currently deprecated in SVG, and scheduled for removal in
                            SVG 2.0. See <xref linkend="svg-2-kerning"/>.</para>
                    </footnote>, ligatures, positional glyph variants) and transformations.
                    Currently works only with TTF (not OTF, TTC, or others).</para>
            </section>
        </section>
        <section>
            <title>A JavaScript approach</title>
            <section>
                <title>Overview</title>
                <para>BLAH BLAH BLAH</para>
            </section>
            <section>
                <title>Implementation</title>
                <para>BLAH BLAH BLAH</para>
                <para><code>getBBox()</code> is not sensitive to transformations that have been
                    applied to an object, and <xref linkend="primer-getBoundingClientRect"/>
                    proposes the use of <code>getCTM()</code> to work around this limitation. We
                    find it simpler to wrap the transformed object(s) in an SVG
                        <code>&lt;g&gt;</code> or <code>&lt;svg&gt;</code> element; because those
                    objects are not themselves transformed, <code>getBBox()</code> reports their
                    actual coordinates correctly even when they contain descendant elements that
                    have undergone transformation with the SVG <code>@transform</code> attribute,
                    such as scaling, rotation, translation, or skewing.</para>
            </section>
            <section>
                <title>Discussion</title>
                <para>Pro: Does not require preparation of font metric information in advance (a
                    benefit both initially and with respect to scalability). Adapts to viewing
                    environment, and therefore supports user overrides of default. Does not require
                    webfont. Does not require additional logic to deal with font effects (e.g.,
                    ligatures, positional glyph variants) or transformations</para>
                <para>Con: Requires JavaScript programming knowledge. Works only in
                    DOM-and-JavaScript-aware environments (e.g., works in a web browser, but not as
                    an included image in a Balisage (Docbook-based) document. Not all JavaScript
                    methods (including <code>getBBox()</code>) are sensitive to transformations that
                    have been performed on an object.</para>
            </section>
        </section>
    </section>
    <section>
        <title>Loose ends and future directions</title>
        <para>Our XSLT approach assumes that the font metrics that can be extracted from the font
            files are sufficient to compute the length of an SVG line of text. Our implementation
            does attempt to access kerning information, and it has not been tested on writing
            systems that involve character substitution (including positional glyph variation or
            ligation) or glyph reordering. It is not impacted negatively by zero-width characters as
            long as the font metrics for those glyphs correctly report a width of zero.</para>
        <para>Font availability on a user system is not fully predictable, especially over time, so
            supplying a webfont is more robust then trusting that every browser will use, for
            example, a Times New Roman font with the same font metrics.</para>
        <para>Saxon-JS</para>
        <para>Saxon-JS relies on a JavaScript implementation of the XSLT engine that is designed to
            perform transformations inside the browser. Insofar as Saxon-JS incorporates both XSLT
            and JavaScript functionality, it may provide a cleaner integration of the two
            approaches.</para>
    </section>
    <section>
        <title>Conclusion</title>
        <para>BLAH BLAH BLAH</para>
    </section>
    <appendix xml:id="extract-widths" xreflabel="Script to extract font widths as XML">
        <title>Script to extract font widths as XML</title>
        <para>The following Python script exports the widths of all glyphs in a TrueType font. The
            script has two positional arguments, a required path to the font and an optional point
            size (defaults to 16, which is the size of SVG text that either does not specify a
                <code>@font-size</code> or specifies a size of <code>"medium"</code>.</para>
        <programlisting language="python" xml:space="preserve">#!/usr/bin/env python
# https://stackoverflow.com/questions/4190667/how-to-get-width-of-a-truetype-font-character-in-1200ths-of-an-inch-with-python
# https://fonttools.readthedocs.io/en/latest/index.html
# https://www.geeksforgeeks.org/create-xml-documents-using-python/
# https://stackoverflow.com/questions/678236/how-to-get-the-filename-without-the-extension-from-a-path-in-python
from fontTools.ttLib import TTFont
from fontTools.ttLib.tables._c_m_a_p import CmapSubtable
from xml.dom import minidom
from matplotlib import font_manager
from pathlib import Path
import argparse

import pprint
pp = pprint.PrettyPrinter(indent=2)

# Validate fontname
# https://stackoverflow.com/questions/15203829/python-argparse-file-extension-checking
def validateFont(fontName):
    """Find full font system path from bare name (without extensions)"""
    installed_fonts = {Path(item).stem: item for item in font_manager.findSystemFonts()}
    return installed_fonts.get(fontName) # returns None on KeyError

def allInstalledFonts():
    """Report all available fonts if user supplies erroneous value"""
    installed_fonts = {Path(item).stem: item for item in font_manager.findSystemFonts()}
    return sorted(installed_fonts.keys())

# Handle command line arguments: font name and optional size
parser = argparse.ArgumentParser()
parser.add_argument("ttf", help="TrueType font name without extension (quote names with spaces)")
parser.add_argument("size", help="size in points (defaults to 16pt)", type=int, nargs="?", default=16)
args = parser.parse_args()
fontName = args.ttf
size = args.size
fontPath = validateFont(fontName) # returns None for erroneous value

if not fontPath: # bail out if font not found
    print(f"Font '{fontName}' not found. Legal fontnames are:")
    pp.pprint(allInstalledFonts())
    quit()

# from StackOverflow
font = TTFont(fontPath, fontNumber=0) # BUG: breaks on ttc, even with fontNumber; table is different?
cmap = font['cmap']
t = cmap.getcmap(3,1).cmap # map of decimal values to glyph names
s = font.getGlyphSet()
units_per_em = font['head'].unitsPerEm

def getTextWidth(text,pointSize):
    total = 0
    for c in text:
        if ord(c) in t and t[ord(c)] in s:
            total += s[t[ord(c)]].width
        else:
            total += s['.notdef'].width
    total = total*float(pointSize)/units_per_em;
    return total

# from minidom documentation
root = minidom.Document()
xml = root.createElement('metrics')
root.appendChild(xml)
metadata = root.createElement('metadata')
metadata.setAttribute('fontName', fontName)
metadata.setAttribute('fontPath', fontPath)
xml.appendChild(metadata)

c_dict = dict()
for num_dec in range(65535): # entire BMP; decimal Unicode value
    char = chr(num_dec) # character as string
    c_dict[char]= getTextWidth(char, size) # default SVG font-size is 16 (medium)

for item in c_dict.items(): # string-value : width
    char = item[0] # string value of character
    num_dec = ord(char) # Unicode value (decimal)
    num_hex = hex(num_dec) # Unicode value (hex)
    width = item[1] # glyph width
    if num_dec in t: # not all values are present in font
        name = t[num_dec] # look up name by decimal value
        e = root.createElement('character')
        e.setAttribute('str', str(char)) # attribute have to be set as strings
        e.setAttribute('dec', str(num_dec))
        e.setAttribute('hex', str(num_hex))
        e.setAttribute('width', str(width))
        e.setAttribute('name', name)
        xml.appendChild(e)

# serialize and render XML
xml_str = root.toprettyxml(indent="  ")
print(xml_str)</programlisting>
        <para>The output is an XML document that looks like the following:</para>
        <programlisting language="xml" xml:space="preserve">&lt;metrics>
  &lt;metadata 
    fontName="Times New Roman" 
    fontPath="/System/Library/Fonts/Supplemental/Times New Roman.ttf" 
    fontSize="16"/>
  &lt;character dec="32" hex="0x20" name="space" str=" " width="4.0"/>
  &lt;character dec="33" hex="0x21" name="exclam" str="!" width="5.328125"/>
  &lt;!-- more characters -->
&lt;/metrics></programlisting>
        <para>The SVG layout strategy described here uses the <code>@str</code> value to retrieve
            the <code>@width</code> value. The <code>@dec</code> (decimal) and <code>@hex</code>
            (hexadecimal) values are not currently used.</para>
    </appendix>
    <bibliography>
        <title>Works cited</title>
        <bibliomixed xml:id="chase2019" xreflabel="Chase 2019">Chase, William R. <quote>Font height
                differences between Windows and Mac.</quote> 2019.
                <link>https://www.williamrchase.com/post/font-height-differences-between-windows-and-mac/</link></bibliomixed>
        <bibliomixed xml:id="deOliveira2017" xreflabel="De Oliveira 2017">De Oliveira, Vincent.
                <quote>Deep dive CSS: font metrics, line-height and vertical-align.</quote> 2017.
                <link>https://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align</link></bibliomixed>
        <bibliomixed xml:id="getBoundingClientRect" xreflabel="MDN getBoundingClientRect()"
                ><quote>Element.getBoundingClientRect()</quote>, MDN Web Docs,
                <link>https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect</link>
        </bibliomixed>
        <bibliomixed xml:id="getBBox" xreflabel="MDN getBBox()"
                ><quote>SVGGraphicsElement.getBBox()</quote>, MDN Web Docs,
                <link>https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox</link>
        </bibliomixed>
        <bibliomixed xml:id="primer-getBoundingClientRect"
            xreflabel="MDN getBoundingClientRect() (Primer)"><quote>getBBox</quote>. <emphasis
                role="ital">An SVG primer for today’s browsers. W3C Working Draft — September
                2010</emphasis>, ed. David Dailey.
                <link>https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#getBBox</link>
        </bibliomixed>
        <bibliomixed xml:id="primer-getCTM" xreflabel="MDN getCTM() (Primer)"
                ><quote>getCTM()</quote>. <emphasis role="ital">An SVG primer for today’s browsers.
                W3C Working Draft — September 2010</emphasis>, ed. David Dailey.
                <link>https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#getCTM</link>
        </bibliomixed>
        <bibliomixed xml:id="svg-2-kerning" xreflabel="SVG 2.0, Kerning">Scalable Vector Graphics
            (SVG) 2 W3C Candidate Recommendation 04 October 2018. §11.10.1.4. The ‘kerning’
            property.
            <link>https://www.w3.org/TR/SVG2/text.html#KerningProperty</link></bibliomixed>
    </bibliography>
</article>
